---
layout: post
title: Java - 함수형 프로그래밍
date: 2025-04-25 21:00:00 + 0900
categories: [java]
tags: [lambda, stream, optional, functional programming]
---
### 강의 : [김영한의 실전 자바 - 고급 3편, 람다, 스트림, 함수형 프로그래밍](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-3/dashboard)

## 1. 디폴트 메서드

### 1-1. 디폴트 메서드 소개

자바는 처음부터 인터페이스와 구현을 명확하게 분리한 언어였다. 인터페이스는 구현없이 메서드의 시그니처만을 정의하는 용도로 사용 되었다.   

- 인터페이스 목적: 코드의 계약을 정의하고 클래스가 어떤 메서드를 반드시 구현하도록 강제해 명세와 구현을 분리하는 것이 주된 목적
- 엄격한 규칙: 인터페이스에 선언되는 메서드는 기본적으로 모두 추상 메서드 였으며, 인터페이스 내에서 구현 내용을 포함할 수 없었다. ```static final``` 필드와 ```abstract``` 메서드 선언만 가능했다.
- 결과: 클래스는 여러 인터페이스를 구현하며 객체지향적인 설계와 다형성을 극대화할 수 있었다.   

자바 8 이전까지는 인터페이스에 새로운 메서드를 추가하면, 인터페이스를 구현한 모든 클래스에서 그 메서드를 구현해야 했다.   
예를 들어 자바가 버전 업을 하면서 ```Collection```, ```List``` 같은 인터페이스에 새로운 기능을 추가했고 개발자가 자바의 버전을 업그레이드 하는 순간 컴파일 오류들이 발생할 것이다.   
이런 문제를 방지하기 위해 자바는 하위호환성을 가장 높은 우선순위에 두고 자바 8에서 디폴트 메서드가 도입되었다.    

#### 디폴트 메서드의 도입 이유

- 하위 호환성 보장: 인터페이스에 새로운 메서드를 추가해도 기존 코드가 깨지지 않도록 하기 위한 목적
- 라이브러리 확장성: 자바가 제공하는 표준 라이브러리에 정의된 인터페이스에 새 메서드를 추가해도 사용자들이나 서드파티 라이브러리 구현체가 일일이 수정하지 않아도 되도록 만듬, 예를 들어 ```List``` 인터페이스에 ```sort(...)``` 메서드가 추가 되었지만 기존의 모든 ```List``` 구현체를 수정하지 않아도 됨
- 람다와 스트림 API 연계: 자바 8에서 함께 도입된 람다와 스트림 API를 보다 편리하게 활용하기 위해 인터페이스에서 구현 로직을 제공, ```Collection``` 인터페이스에 ```stream()``` 디폴트 메서드 추가, ```Iterable``` 인터페이스에 ```forEach``` 디폴트 메서드 추가   
- 설계 유연성 확장: 디폴트 메서드를 통해 인터페이스에서도 일부 공통 동작 방식을 정의할 수 있다.

```java
public interface MyInterface {
    void existingMethod();

    default void newMethod() {
        System.out.println("새로 추가된 디폴트 메서드입니다.");
    }
}
```

### 1-2. 디폴트 메서드의 올바른 사용법

1. 하위 호환성을 위해 최소한으로 사용
2. 인터페이스는 여전히 추상화의 역할
    - 디폴트 메서드는 하위 호환을 위한 기능이므로 공통으로 쓰기 쉬운 간단한 로직을 제공하는 정도가 이상적이다.
    - 로직 구현은 별도 클래스에 두고 인터페이스는 계약의 역할에 충실한 것이 좋다.
3. 다중 상속 시 충돌 문제
    - 하나의 클래스가 여러 인터페이스를 동시에 구현할 때, 서로 다른 인터페이스에 동일한 시그니처의 디폴트 메서드가 존재하면 충돌이 일어난다.   
    - 이 경우 구현 클래스에서 반드시 메서드를 재정의해야 하고 직접 구현 로직을 작성하거나 어떤 인터페이스의 디폴트 메서드를 쓸 것인지 명시해야 한다.   
4. 디폴트 메서드에 상태를 두지 않기
    - 인스턴스 변수를 활용하거나 여러 차례 호출 시 상태에 따라 동작이 달라지는 등의 동작은 지양해야 한다. 
    - 이런 로직은 클래스로 옮기는 것이 더 적절하다.

